/*** VER: 1.0* DATE: 09 July 2013* FLA: AS3* This Banner template was developed to improve the production process of creating OLA Standard Banners.* Achieved by reducing repetitive tasks that clog up resources and process standardisation.* The 'Main' class controls the timeline of the creative. This is managed through a switch contained in the 'playBanner' function.* The banner will calculate how many frames are in the creative through the frameHolder clips placed on the stage. All 'required'* functionality is managed in the 'Framework.as' class, this includes;clicktag, keyline, masks, banner timer, frameCounter and frameForward.* Any other external Classes used need to be loaded inside of this 'Main.as' class.* For explanation of the TweenLite package see http://www.greensock.com/tweenlite/* @author Alex Greaves, alex@wearesuburb.com*/package {	import flash.display.*;	// = = = = Class Imports = = = =	import framework.Framework;  // = = Import the framework class	// * * Import any additional individual classes from the animation folder	import animation.ExampleClass;	// = = = = TweenLite Imports = = = =	import com.greensock.TweenLite;  // = = Import TweenLite classes	import com.greensock.easing.*; // = = 	public class Main extends Framework {		// = = = = Add Classes = = = =		// * * Reference all imported additional classes		var example:ExampleClass;		// = = = = Global variables = = = =		frameName = 'frameHolder'; // = = Set the name for your generic frameHolder clips. Provided 'frame' is used the banner will work . Default is 'frameHolder'.		numberOfFrames = 2; // = = set how many different frames the creative contains. Default is 1.		doesTheBannerLoop = true; // = = Set whether or not the current creative should loop. Default is false.		requiredLoops = 2; // = = How many times should the current banner loop. Default is 0.		// = = = = Main function = = = =		public function Main() {			example = new ExampleClass(this.stage); // = = Add an individual class and pass in a reference to the main stage						createClickButton('clickTAG'); // = = Create a clicktag. clicktag version can be sent as a string. eg. clickTag, CLICKTAG, clicktag, ClickTag. If a clicktag has been supplied by the publisher, then the publishers clicktag version will overrule a manually added clicktag 			createKeyline(1, 0x000000); // = = Create a keyline around the edge of the stage. Requires line width and colour. Default is 'lineWidth = 1 and colour = 0x000'						// testing_jumpToFrame(2); // = = Uncomment this for testing purposes and pass in the required frame number			buildStage();// = = Add all frameHolder_ and background_ Classes to stage with an alpha of 0. Extra classes can be passed to the function through an array eg. '[targetName1, targetName2, targetName3]'. Any new MovieClips will have to be defined through getChildByName('targetMovieClipName') - See line 65			// = = = = Should not be changed = = = =			playBanner(frameSwitch); // = = Start the banner animation. Requires 'frameswitch' String to be passed in			trace('@M: Banner has started playing at frame ' + frameSwitch);		}		// = = = = start Banner = = = =		public function playBanner(whichFrame):void { 			// = = playBanner function is based on the String 'frameSwitch. Without a relevant String the banner will not play			// = = = = Should not be changed = = = =			currentFrame = getChildByName(frameName + frameCounter) as MovieClip; // = =  Sets the current frameHolder to target			trace('@M: currentFrame is ' + currentFrame.name + ', and is of type: ' + currentFrame);			currentFrame.alpha = 1;			// = = Define extra classes added into 'buildStage' function 			// * * Add references to additional MovieClips to be used by TweenLite			// otherMovieClip = getChildByName(movieClipName) as MovieClip;			// = = = = Timeline Animation controlled here = = = =			switch (whichFrame) {			// = = switch based on the string given to the playBanner function				case '1-in':					// = = = = Animation = = = =					TweenLite.from(currentFrame.copy, 0.5, {alpha:0});					TweenLite.from(currentFrame.img_test, 0.5, {delay:0.5, alpha:0});					TweenLite.from(currentFrame.subCopy, 0.5, {delay:1, alpha:0});					TweenLite.from(currentFrame.suburbLogo, 0.5, {delay:1.5, y:0-currentFrame.suburbLogo.height, ease:Bounce.easeOut});					TweenLite.delayedCall(2.5, playBanner, [frameForward()]); // = = Progresses the animation to the next frame after an amount of time. This amount of time should always be at a minimum the longest delay + longest tween. Then any amount of delay can be added on top of this					break;				case '1-out':					// = = = = Animation = = = =					TweenLite.to(currentFrame.copy, 0.5, {alpha:0});					TweenLite.to(currentFrame.img_test, 0.5, {delay:0.5, alpha:0});					TweenLite.to(currentFrame.subCopy, 0.5, {delay:1, alpha:0});					TweenLite.to(currentFrame.suburbLogo, 0.5, {delay:1, y:0-currentFrame.suburbLogo.height, ease:Bounce.easeOut});					TweenLite.delayedCall(1.5, playBanner, [frameForward()]); // = = Progresses the animation to the next frame after a designated amount of time. This amount of time should always be at a minimum the longest delay + longest tween. Then any amount of delay can be added on top of this					break;				case '2-in':					// = = = = Animation = = = =					TweenLite.from(currentFrame.copy, 0.5, {x:stage.stageWidth+this.width});					TweenLite.from(currentFrame.img_test, 0.5, {delay:0.5, alpha:0});					TweenLite.from(currentFrame.subCopy, 0.5, {delay:1, alpha:0});					TweenLite.from(currentFrame.suburbLogo, 0.5, {delay:1.5, y:0-currentFrame.suburbLogo.height, ease:Bounce.easeOut});					TweenLite.delayedCall(2.5, playBanner, [frameForward()]); // = = Progresses the animation to the next frame after a designated amount of time. This amount of time should always be at a minimum the longest delay + longest tween. Then any amount of delay can be added on top of this					break;				case '2-out':				// = = [numberOfFrames]'-out' is only called when 'doesTheBannerLoop' is set to true					// = = = = Animation = = = =					TweenLite.to(currentFrame.copy, 0.5, {alpha:0});					TweenLite.to(currentFrame.img_test, 0.5, {delay:0.5, alpha:0});					TweenLite.to(currentFrame.subCopy, 0.5, {delay:1, alpha:0});					TweenLite.to(currentFrame.suburbLogo, 0.5, {delay:1, y:0-currentFrame.suburbLogo.height, ease:Bounce.easeOut});					TweenLite.delayedCall(1.5, loopBanner, [playBanner, frameForward()]); // = = Loop Banner resets the stage and restarts the animation after a designated amount of time. This amount of time should always be at a minimum the longest delay + longest tween. Then any amount of delay can be added on top of this					break;				case 'endFrame':					endTimer(); // = = do not change. traces the length of the banner in seconds					break;				default:					trace('@M: OOPS! Something went wrong at frame '+ whichFrame + ', loop' + loopCounter);					break;			}			trace ('@M: current frame is ' + whichFrame);		}	}}